//alert("app.js loaded"); Enable for Debug
let mode = "config"; // "config" | "edit"

const autoQuoteItems = {};   // preview items generated by rules
let editableRows = [];       // final rows sales can edit after Next
const truckConfiguratorState = {};
const autoTruckQuoteItems = {};
let truckEditableRows = [];
let truckDraggedIndex = null;
let truckMode = "config"; // "config" | "edit"

// =========================
// Debug Panel
// - UI markup lives in index.html (#debugPanel + #debugOpenFab)
// - Exposes window.DEBUG helpers
// - Toggle with Ctrl+Shift+D
// =========================
(function initDebugPanel() {
  const state = {
    enabled: false,
    lastRequest: {},
    lastResponse: {},
    unresolved: [],
    log: [],
  };

  function safeJson(obj) {
    try {
      return JSON.stringify(obj ?? {}, null, 2);
    } catch {
      return String(obj);
    }
  }

  function el(id) {
    return document.getElementById(id);
  }

  function render() {
    const req = el("debugLastRequest");
    const res = el("debugLastResponse");
    const unr = el("debugUnresolved");
    const log = el("debugLog");
    if (req) req.textContent = safeJson(state.lastRequest);
    if (res) res.textContent = safeJson(state.lastResponse);
    if (unr) unr.textContent = safeJson(state.unresolved);
    if (log) log.textContent = state.log.join("\n");
  }

  function addLog(line) {
    const ts = new Date().toLocaleTimeString();
    state.log.push(`[${ts}] ${line}`);
    if (state.log.length > 300) state.log.shift();
    render();
  }

  function show() {
    const panel = el("debugPanel");
    if (panel) panel.classList.remove("debug-hidden");
    state.enabled = true;
    const fab = el("debugOpenFab");
    if (fab) fab.style.display = "none";
    addLog("Debug panel opened");
  }

  function hide() {
    const panel = el("debugPanel");
    if (panel) panel.classList.add("debug-hidden");
    state.enabled = false;
    const fab = el("debugOpenFab");
    if (fab) fab.style.display = "block";
  }

  function toggle() {
    const panel = el("debugPanel");
    const hidden = panel?.classList.contains("debug-hidden");
    if (hidden) show(); else hide();
  }

  function clear() {
    state.lastRequest = {};
    state.lastResponse = {};
    state.unresolved = [];
    state.log = [];
    render();
  }

  function copyJson() {
    const payload = {
      lastRequest: state.lastRequest,
      lastResponse: state.lastResponse,
      unresolved: state.unresolved,
      log: state.log,
    };
    const text = safeJson(payload);
    if (navigator.clipboard && navigator.clipboard.writeText) {
      navigator.clipboard.writeText(text).then(() => addLog("Copied debug JSON to clipboard"));
    } else {
      window.prompt("Copy debug JSON:", text);
    }
  }

  // Public API
  window.DEBUG = {
    isEnabled: () => state.enabled,
    log: (msg) => addLog(String(msg)),
    setRequest: (obj) => {
      state.lastRequest = obj ?? {};
      render();
    },
    setResponse: (obj) => {
      state.lastResponse = obj ?? {};
      render();
    },
    setUnresolved: (arr) => {
      state.unresolved = Array.isArray(arr) ? arr : [];
      render();
    },
    show,
    hide,
    toggle,
    clear,
    copyJson,
  };

  // Wire buttons + hotkey
  document.addEventListener("DOMContentLoaded", () => {
    const fab = el("debugOpenFab");
    const toggleBtn = el("debugToggleBtn");
    const clearBtn = el("debugClearBtn");
    const copyBtn = el("debugCopyBtn");

    if (fab) fab.addEventListener("click", show);
    if (toggleBtn) toggleBtn.addEventListener("click", toggle);
    if (clearBtn) clearBtn.addEventListener("click", clear);
    if (copyBtn) copyBtn.addEventListener("click", copyJson);

    // Ctrl+Shift+D toggles
    document.addEventListener("keydown", (e) => {
      const key = String(e.key || "").toLowerCase();
      if (e.ctrlKey && e.shiftKey && key === "d") {
        e.preventDefault();
        toggle();
      }
    });

    // Start hidden (FAB visible)
    hide();
  });
})();


document.addEventListener("DOMContentLoaded",() => {

// ---------------------------------------------------------
  // 1. INITIALIZE CACHE
  // We use sessionStorage so pricing remembers choices during 
  // the session but clears if they close the tab (keeping prices fresh).
  // ---------------------------------------------------------
  let itemCache = {};
  try {
    const saved = sessionStorage.getItem("strivenItemCache");
    if (saved) {
      itemCache = JSON.parse(saved);
    }
  } catch (e) {
    console.warn("Could not load item cache", e);
  }

  function saveCache() {
    try {
      sessionStorage.setItem("strivenItemCache", JSON.stringify(itemCache));
    } catch (e) { /* ignore quota errors */ }
  }

function getBodyFieldIdsFromPricingData() {
  // Anything top-level that has .options is considered a body dropdown field
  // We exclude "truck" and "rules"
  const exclude = new Set(["truck", "rules"]);
  return Object.keys(pricingData)
    .filter(k => !exclude.has(k))
    .filter(k => pricingData[k] && pricingData[k].options);
}
function buildBodyConfiguratorUI() {
  const bodyFieldIds = getBodyFieldIdsFromPricingData();

  // All body dropdowns should live in the scrolling questions area so they
  // look identical to the truck builder and never appear under Back/Next.
  const questionsHost = document.getElementById("bodyQuestions") || document.getElementById("configurator");
  if (!questionsHost) return;

  for (const fieldId of bodyFieldIds) {
    // Ensure a <select> exists; if not, auto-create it (so we don't rely on hard-coded HTML)
    let select = document.getElementById(fieldId);
    if (!select) {
      const wrapper = document.createElement("div");
      wrapper.className = "field";

      const label = document.createElement("label");
      label.setAttribute("for", fieldId);
      label.textContent = (pricingData[fieldId]?.label || fieldId);

      select = document.createElement("select");
      select.id = fieldId;

      wrapper.appendChild(label);
      wrapper.appendChild(select);
      questionsHost.appendChild(wrapper);
    } else {
      // If this select exists but isn't wrapped nicely, we leave it alone.
      // (Hard-coded selects in HTML already match the style.)
    }

    // Populate options
    populateDropdown(fieldId);

    // Wire change handler
    select.onchange = () => {
      configuratorState[fieldId] = select.value;
      applyRules();
      console.log("Body configuratorState:", configuratorState);
    };
  }
}

let pricingData = {};

function roundMoney(value) {
  const dec = (pricingData && pricingData.pricingSettings && pricingData.pricingSettings.rounding && pricingData.pricingSettings.rounding.decimals) || 2;
  const factor = Math.pow(10, dec);
  return Math.round((Number(value) + Number.EPSILON) * factor) / factor;
}
function getUpchargeRate() {
  return (pricingData && pricingData.pricingSettings && typeof pricingData.pricingSettings.upchargeRate === "number")
    ? pricingData.pricingSettings.upchargeRate
    : 0;
}
function getBodyBaseCost(series) {
  const map = pricingData && pricingData.pricingSettings && pricingData.pricingSettings.bodyBaseCostBySeries;
  if (!map) return null;
  return (series && map[series] != null) ? Number(map[series]) : null;
}
async function loadPricingData() {
  const response = await fetch("data.json");
  pricingData = await response.json();

  buildBodyConfiguratorUI();
  buildTruckConfiguratorUI();
}

loadPricingData();

const quoteSection = document.getElementById("quoteSection");
const quoteBody = document.getElementById("quoteBody");
const quoteBack = document.getElementById("quoteBack");
const quoteItems = {};
const configuratorState = {};
const startBlank = document.getElementById("startBlank");
const startConfigurator = document.getElementById("startConfigurator");
console.log("startConfigurator:", startConfigurator);
const configurator = document.getElementById("configurator");
const back = document.getElementById("back");
const printQuoteBtn = document.getElementById("printQuote");
  const copyBodyToStrivenBtn = document.getElementById("copyBodyToStriven");
const truckQuoteSection = document.getElementById("truckQuoteSection");
const truckQuoteBody = document.getElementById("truckQuoteBody");
const truckBack = document.getElementById("truckBack");
const truckNext = document.getElementById("truckNext");
const truckQuoteBack = document.getElementById("truckQuoteBack");
const saveTruckQuoteBtn = document.getElementById("saveTruckQuote");
const printTruckQuoteBtn = document.getElementById("printTruckQuote");
  const copyTruckToStrivenBtn = document.getElementById("copyTruckToStriven");
const bodyQuoteNext = document.getElementById("bodyQuoteNext");
const truckConfigurator = document.getElementById("truckConfigurator");
const bodyQuoteActions = document.getElementById("bodyQuoteActions");
const truckQuoteActions = document.getElementById("truckQuoteActions");
const openSavedQuotesBtn = document.getElementById("openSavedQuotes");
const savedQuotesScreen = document.getElementById("savedQuotes");
const savedQuotesList = document.getElementById("savedQuotesList");
const savedQuotesBack = document.getElementById("savedQuotesBack");


// New layout wrappers (so quote-only views can be full width)
const bodyBuilderGrid = document.getElementById("bodyBuilderGrid");
const truckBuilderGrid = document.getElementById("truckBuilderGrid");

// Table footers for Totals
const quoteFoot = document.getElementById("quoteFoot");
const truckQuoteFoot = document.getElementById("truckQuoteFoot");

function clearModeClasses() {
  document.body.classList.remove("mode-body-quote", "mode-truck-quote");
}

function setModeClass(cls) {
  clearModeClasses();
  if (cls) document.body.classList.add(cls);
}

function parseMoneyLoose(v) {
  const n = Number(String(v ?? "").replace(/[^0-9.\-]/g, ""));
  return Number.isFinite(n) ? n : 0;
}

function renderTotalFooter(tfootEl, totalValue) {
  if (!tfootEl) return;
  const table = tfootEl.closest("table");
  const thCount = table ? table.querySelectorAll("thead th").length : 0;
  const totalText = `$${Number(roundMoney(totalValue)).toFixed(2)}`;

  if (thCount <= 2) {
    tfootEl.innerHTML = `
      <tr>
        <td class="totalLabel">Total</td>
        <td class="totalValue">${totalText}</td>
      </tr>
    `;
    return;
  }

  // 4-col edit table: Move | Description | Price | Actions
  if (thCount === 4) {
    tfootEl.innerHTML = `
      <tr>
        <td class="totalLabel" colspan="2">Total</td>
        <td class="totalValue">${totalText}</td>
        <td></td>
      </tr>
    `;
    return;
  }

  // Fallback: put label in first cell, value in last
  const cols = thCount || 2;
  const tds = [];
  for (let i = 0; i < cols; i++) {
    if (i == 0) tds.push('<td class="totalLabel">Total</td>');
    else if (i == cols - 1) tds.push(`<td class="totalValue">${totalText}</td>`);
    else tds.push('<td></td>');
  }
  tfootEl.innerHTML = `<tr>${tds.join("")}</tr>`;
}

async function resolveByItemNumbers(itemNumbers, sourcesByNumber = {}, context = {}) {
    // 1. Clean inputs
    const safeNums = Array.isArray(itemNumbers)
      ? itemNumbers.map(x => String(x).trim()).filter(Boolean)
      : [];

    if (safeNums.length === 0) return [];

    // 2. Identify what is missing from the cache
    const missingNums = safeNums.filter(num => !itemCache[num]);

    // 3. If we have missing items, fetch ONLY those from backend
    if (missingNums.length > 0) {
      try {
        if (window.DEBUG) {
          window.DEBUG.log(`Cache miss. Fetching ${missingNums.length} items: ${missingNums.join(", ")}`);
        }

        // 1. Determine the correct URL
const BASE_URL = window.location.hostname === 'localhost' 
  ? 'http://localhost:5000' 
  : 'https://online-truck-configurator.onrender.com';

// 2. Use that URL in your fetch
const res = await fetch(`${BASE_URL}/api/resolve-by-number`, {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ itemNumbers: missingNums })
});

        if (!res.ok) throw new Error("Backend resolve failed");
        
        const data = await res.json();
        const newLines = Array.isArray(data?.lines) ? data.lines : [];

        // 4. Update Cache with new results
        newLines.forEach(line => {
          // Store by the *requested* number and the *official* number to be safe
          const reqKey = String(line.requestedItemNumber || "").trim();
          const offKey = String(line.itemNumber || "").trim();
          
          if (reqKey) itemCache[reqKey] = line;
          if (offKey) itemCache[offKey] = line;
        });

        saveCache(); // Persist to session storage

      } catch (err) {
        console.error("Error resolving items:", err);
        // We continue, so at least cached items return. 
        // Missing items will remain undefined in the UI (or show loading).
      }
    } else {
      if (window.DEBUG) {
        window.DEBUG.log(`All ${safeNums.length} items found in cache. 0 API calls.`);
      }
    }

    // 5. Return FULL list (Cached + Newly Fetched)
    // We map the original 'safeNums' list to the objects in cache.
    // If an item failed to load, it might be undefined here.
    return safeNums.map(num => itemCache[num]).filter(Boolean);
  }

function buildSourcesByNumber(mapObj, stage) {
  const out = {};
  if (!mapObj) return out;

  const pickLabel = (fieldId) => {
    try {
      if (stage === 'truck') {
        return pricingData?.truck?.[fieldId]?.label || fieldId;
      }
      return pricingData?.[fieldId]?.label || fieldId;
    } catch {
      return fieldId;
    }
  };

  for (const key of Object.keys(mapObj)) {
    const it = mapObj[key];
    const num = String(it?.itemNumber ?? '').trim();
    if (!num) continue;

    // Prefer explicit source metadata if present
    let fieldId = it?.sourceFieldId;
    let optValue = it?.sourceOptValue;

    // Fall back to parsing from key: "fieldId:optValue:itemNumber" or "fieldId:optValue:..."
    if (!fieldId || optValue == null) {
      const parts = String(key).split(':');
      if (!fieldId && parts.length >= 1) fieldId = parts[0];
      if (optValue == null && parts.length >= 2) optValue = parts[1];
    }

    const source = {
      stage,
      key: String(key),
      fieldId: fieldId || '',
      fieldLabel: fieldId ? pickLabel(fieldId) : '',
      optValue: (optValue != null ? String(optValue) : '')
    };

    out[num] = out[num] || [];
    out[num].push(source);
  }

  return out;
}

async function refreshAutoQuoteFromStriven() {
  // 1) Collect itemNumbers currently in your auto quote
  const itemNumbers = Object.values(autoQuoteItems)
    .map(x => x.itemNumber)
    .filter(Boolean);

  // If nothing selected yet, just render an empty preview
  if (itemNumbers.length === 0) {
    renderQuote();
    return;
  }

  const resolvedLines = await resolveByItemNumbers(itemNumbers, buildSourcesByNumber(autoQuoteItems, 'body'), {stage: 'body'});

  // 3) Update autoQuoteItems with Striven results
  // We'll match by itemNumber
  const byNumber = {};
  for (const line of resolvedLines) {
    const k = String(line?.requestedItemNumber ?? line?.itemNumber ?? "").trim();
    const k2 = String(line?.itemNumber ?? "").trim();
    if (k) byNumber[k] = line;
    if (k2) byNumber[k2] = line;
  }

  for (const key in autoQuoteItems) {
    const prev = autoQuoteItems[key];
    const num = String(prev?.itemNumber ?? "").trim();
    const line = byNumber[num];

    if (!line) continue; // if missing mapping or API error, leave it alone

    // IMPORTANT: merge into existing object so we do NOT lose flags like `hidden`
    // (otherwise add-ons briefly collapse, then reappear after refresh).
    autoQuoteItems[key] = {
      ...prev,
      itemNumber: num,
      description: (line.workDescription ?? prev.description ?? ""),
      price: (line.roundedTotal != null ? line.roundedTotal : prev.price),
      rawPrice: line.rawTotal,
      kind: line.kind,
      id: line.id
    };
  }

  // 4) Re-render quote table
  renderQuote();
}

async function refreshAutoTruckQuoteFromStriven() {
  const itemNumbers = Object.values(autoTruckQuoteItems)
    .map(x => x.itemNumber)
    .filter(Boolean)
    .map(x => String(x).trim())
    .filter(Boolean);

  if (itemNumbers.length === 0) {
    renderTruckPreview();
    return;
  }

  const resolvedLines = await resolveByItemNumbers(itemNumbers, buildSourcesByNumber(autoTruckQuoteItems, 'truck'), {stage: 'truck'});

  const byNumber = {};
  for (const line of resolvedLines) {
    const k = String(line?.requestedItemNumber ?? line?.itemNumber ?? "").trim();
    const k2 = String(line?.itemNumber ?? "").trim();
    if (k) byNumber[k] = line;
    if (k2) byNumber[k2] = line;
  }

  for (const key in autoTruckQuoteItems) {
    const prev = autoTruckQuoteItems[key];
    const num = String(prev?.itemNumber ?? "").trim();
    const line = byNumber[num];
    if (!line) continue;

    autoTruckQuoteItems[key] = {
      ...prev,
      itemNumber: num,
      description: (line.workDescription ?? prev.description ?? ""),
      price: (line.roundedTotal != null ? line.roundedTotal : prev.price),
      rawPrice: line.rawTotal,
      kind: line.kind,
      id: line.id
    };
  }

  // Re-render truck preview after Striven resolution
  renderTruckPreview();

  try {
    if (window.DEBUG) window.DEBUG.log("Truck preview refreshed after Striven resolve");
  } catch {}
}

function hideAllScreens() {
  // Reset layout modes
  clearModeClasses();

  // Wrapper grids
  if (bodyBuilderGrid) bodyBuilderGrid.style.display = "none";
  if (truckBuilderGrid) truckBuilderGrid.style.display = "none";

  // Legacy inner cards (kept for safety)
  if (configurator) configurator.style.display = "none";
  if (quoteSection) quoteSection.style.display = "none";
  if (bodyQuoteActions) bodyQuoteActions.style.display = "none";

  if (blankQuote) blankQuote.style.display = "none";

  if (truckConfigurator) truckConfigurator.style.display = "none";
  if (truckQuoteSection) truckQuoteSection.style.display = "none";
  if (truckQuoteActions) truckQuoteActions.style.display = "none";

  if (savedQuotesScreen) savedQuotesScreen.style.display = "none";
}

// Build the rows for the *editable* body quote, using the same pricing logic
// as the preview (base body cost override + hidden adders folded into base).
function buildBodyEditableRowsFromAutoQuote() {
  const upRate = getUpchargeRate();

  // Collect hidden body spec adders (priced, but not displayed)
  const hiddenAdders = [];
  for (const k in autoQuoteItems) {
    const it = autoQuoteItems[k];
    if (it && it.hidden) hiddenAdders.push(it);
  }

  // Identify body base line (the bodyLength-derived item number)
  const bodySeries = configuratorState.bodySeries || "";
  const bodyLength = configuratorState.bodyLength || "";
  const bodyItemNumber = (bodySeries && bodyLength) ? `${bodySeries} ${bodyLength}` : "";

  let bodyBaseKey = null;
  for (const k in autoQuoteItems) {
    const it = autoQuoteItems[k];
    if (!it || it.hidden) continue;
    if (bodyItemNumber && String(it.itemNumber || "") === bodyItemNumber) {
      bodyBaseKey = k;
      break;
    }
  }

  // Visible lines
  const visible = [];
  for (const k in autoQuoteItems) {
    const it = autoQuoteItems[k];
    if (!it || it.hidden) continue;
    visible.push({
      key: k,
      item: it,
      basePrice: Number(it.price || 0),
      desc: String(it.description || "")
    });
  }

  // Override body base price and fold hidden adders into it
  if (bodyBaseKey) {
    const baseCost = getBodyBaseCost(bodySeries);
    let addersTotal = 0;
    for (const ad of hiddenAdders) {
      const p = Number(ad.price || 0);
      if (!Number.isNaN(p)) addersTotal += p;
    }

    for (const v of visible) {
      if (v.key === bodyBaseKey) {
        const existing = Number(v.basePrice || 0);
        v.basePrice = (baseCost != null ? baseCost : existing) + addersTotal;

        // Append selected (priced) specs under the body description (only those with adders)
        const specLines = hiddenAdders
          .filter(a => a.specLabel && a.specValue)
          .map(a => `${a.specLabel}: ${a.specValue}`);
        if (specLines.length) {
          v.desc = `${v.desc}\nAdd-ons:\n- ${specLines.join("\n- ")}`;
        }
        break;
      }
    }
  }

  // Apply upcharge on the sum (then rounding), same as preview
  const totalBase = visible.reduce((sum, v) => sum + (Number(v.basePrice) || 0), 0);
  const targetTotal = roundMoney(totalBase * (1 + upRate));

  let runningTotal = 0;
  for (const v of visible) {
    v.upPrice = roundMoney((Number(v.basePrice) || 0) * (1 + upRate));
    runningTotal += v.upPrice;
  }
  runningTotal = roundMoney(runningTotal);

  const diff = roundMoney(targetTotal - runningTotal);
  if (diff !== 0 && bodyBaseKey) {
    for (const v of visible) {
      if (v.key === bodyBaseKey) {
        v.upPrice = roundMoney(v.upPrice + diff);
        break;
      }
    }
  }

  return visible.map(v => ({
    description: v.desc,
    price: v.upPrice
  }));
}
function buildTruckConfiguratorUI() {
  const container = document.getElementById("truckQuestions");
  if (!container) return;

  container.innerHTML = "";

  const truck = pricingData.truck;
  if (!truck) {
    container.innerHTML = "<p>No truck questions found in data.json yet.</p>";
    return;
  }

  for (const fieldId in truck) {
    const field = truck[fieldId];

    // wrapper
    const row = document.createElement("div");
    row.style.marginBottom = "12px";

    const label = document.createElement("label");
    label.textContent = (field.label || fieldId) + ": ";
    label.setAttribute("for", fieldId);

    const select = document.createElement("select");
    select.id = fieldId;

    // default
    const defaultOpt = document.createElement("option");
    defaultOpt.value = "";
    defaultOpt.textContent = "Select One";
    select.appendChild(defaultOpt);

    // options
    for (const optValue in field.options) {
      const opt = document.createElement("option");
      opt.value = optValue;
      opt.textContent = optValue;
      select.appendChild(opt);
    }

    // change listener
    select.addEventListener("change", () => {
      truckConfiguratorState[fieldId] = select.value;
      applyTruckRules();
    });

    row.appendChild(label);
    row.appendChild(select);
    container.appendChild(row);
  }
}

openSavedQuotesBtn.addEventListener("click", () => {
  // Hide start buttons
  startBlank.style.display = "none";
  startConfigurator.style.display = "none";
  openSavedQuotesBtn.style.display = "none";

  hideAllScreens();
  savedQuotesScreen.style.display = "block";

  renderSavedQuotesList();
});
savedQuotesBack.addEventListener("click", () => {
  hideAllScreens();

  // Show start buttons
  startBlank.style.display = "inline-block";
  startConfigurator.style.display = "inline-block";
  openSavedQuotesBtn.style.display = "inline-block";
});


startConfigurator.addEventListener("click", () => {
  // Hide start buttons
  startBlank.style.display = "none";
  startConfigurator.style.display = "none";
  openSavedQuotesBtn.style.display = "none";

  hideAllScreens();
  setModeClass(null); // builder mode

  // Enter Body Configurator (preview mode)
  mode = "config";

  // Show the body builder grid (left options + right quote)
  if (bodyBuilderGrid) bodyBuilderGrid.style.display = "grid";
  configurator.style.display = "block";
  quoteSection.style.display = "block";
  bodyQuoteActions.style.display = "none";

  // Ensure truck grid stays hidden
  if (truckBuilderGrid) truckBuilderGrid.style.display = "none";

  ensurePreviewHeaders();
  renderQuote();
});

back.addEventListener("click", () => {
  // Exit body builder back to home
  hideAllScreens();

  startBlank.style.display = "inline-block";
  startConfigurator.style.display = "inline-block";
  openSavedQuotesBtn.style.display = "inline-block";
});


const blankQuote = document.getElementById("blankQuote");
const blankBack = document.getElementById("blankBack");

startBlank.addEventListener("click", () => {
  startBlank.style.display = "none";
  startConfigurator.style.display = "none";
  blankQuote.style.display = "block";
});

blankBack.addEventListener("click", () => {
  blankQuote.style.display = "none";
  startBlank.style.display = "inline-block";
  startConfigurator.style.display = "inline-block";
});
const bodySeriesSelect = document.getElementById("bodySeries");

const bodyLengthSelect = document.getElementById("bodyLength");

const nextButton = document.getElementById("next");

nextButton.addEventListener("click", () => {
  // Switch into body quote edit mode (quote-only layout)
  mode = "edit";
  setModeClass("mode-body-quote");

  // Snapshot the current preview (base body + add-ons folded) into editable rows
  editableRows = buildBodyEditableRowsFromAutoQuote();

  if (editableRows.length === 0) editableRows.push({ description: "", price: "" });

  // Show edit controls
  ensureEditHeaders();
  renderQuote();

  // Hide left panel, keep grid visible so quote can expand
  configurator.style.display = "none";
  if (bodyBuilderGrid) bodyBuilderGrid.style.display = "grid";

  quoteSection.style.display = "block";
  bodyQuoteActions.style.display = "block";
});

quoteBack.addEventListener("click", () => {
  // Go back to configurator questions
  mode = "config";
  setModeClass(null);

  // Show builder layout again
  if (bodyBuilderGrid) bodyBuilderGrid.style.display = "grid";
  configurator.style.display = "block";
  quoteSection.style.display = "block";
  bodyQuoteActions.style.display = "none";

  // Restore dropdown UI from state
  bodySeriesSelect.value = configuratorState.bodySeries || "";
  bodyLengthSelect.value = configuratorState.bodyLength || "";

  applyRules();
  renderQuote();
});

function getRules(stage) {
  return (pricingData.rules && pricingData.rules[stage]) ? pricingData.rules[stage] : [];
}

function resetAllOptionsForStage(stage) {
  if (stage === "body") {
    // show everything for all body dropdowns (auto-built from data.json)
    const bodyFields = getBodyFieldIdsFromPricingData();
    bodyFields.forEach(fieldId => {
      const select = document.getElementById(fieldId);
      if (!select) return;
      Array.from(select.options).forEach(opt => {
        if (opt.value === "") return; // keep placeholder
        opt.hidden = false;
        opt.disabled = false;
      });
    });
  }
  if (stage === "truck") {
    const truck = pricingData.truck;
    if (!truck) return;
    for (const fieldId in truck) {
      const select = document.getElementById(fieldId);
      if (!select) continue;
      Array.from(select.options).forEach(opt => {
        if (opt.value === "") return;
        opt.hidden = false;
        opt.disabled = false;
      });
    }
  }
}

function matchesWhen(state, whenObj) {
  // all keys in whenObj must match exactly
  for (const key in whenObj) {
    if ((state[key] || "") !== String(whenObj[key])) return false;
  }
  return true;
}

function applyDataDrivenRules(stage, state) {
  // 1) reset all options visible
  resetAllOptionsForStage(stage);

  // 2) apply hide rules
  const rules = getRules(stage);
  for (const rule of rules) {
    if (!matchesWhen(state, rule.when || {})) continue;

    const hideList = rule.hideOptions || [];
    for (const hide of hideList) {
      const select = document.getElementById(hide.field);
      if (!select) continue;

      for (const val of (hide.values || [])) {
        setOptionVisible(select, String(val), false);

        // if it was selected, clear it
        if (select.value === String(val)) {
          select.value = "";
          state[hide.field] = "";
        }
      }
    }
  }
}


function renderPreviewQuote() {
  ensurePreviewHeaders();
  quoteBody.innerHTML = "";

  const upRate = getUpchargeRate();

  // Collect hidden body spec adders (priced, but not displayed)
  const hiddenAdders = [];
  for (const k in autoQuoteItems) {
    const it = autoQuoteItems[k];
    if (it && it.hidden) hiddenAdders.push(it);
  }

  // Identify body base line (the bodyLength-derived item number)
  const bodySeries = configuratorState.bodySeries || "";
  const bodyLength = configuratorState.bodyLength || "";
  const bodyItemNumber = (bodySeries && bodyLength) ? `${bodySeries} ${bodyLength}` : "";

  let bodyBaseKey = null;
  for (const k in autoQuoteItems) {
    const it = autoQuoteItems[k];
    if (!it || it.hidden) continue;
    if (bodyItemNumber && String(it.itemNumber || "") === bodyItemNumber) {
      bodyBaseKey = k;
      break;
    }
  }

  // Build visible items list and base prices (with body base override + hidden adders folded in)
  const visible = [];
  for (const k in autoQuoteItems) {
    const it = autoQuoteItems[k];
    if (!it || it.hidden) continue;
    visible.push({ key: k, item: it, basePrice: Number(it.price || 0) });
  }

  // Override body base price and fold hidden adders into it
  if (bodyBaseKey) {
    const baseCost = getBodyBaseCost(bodySeries);
    let addersTotal = 0;
    for (const ad of hiddenAdders) {
      const p = Number(ad.price || 0);
      if (!Number.isNaN(p)) addersTotal += p;
    }
    const bodyBase = (baseCost != null ? baseCost : Number(autoQuoteItems[bodyBaseKey].price || 0)) + addersTotal;

    for (const v of visible) {
      if (v.key === bodyBaseKey) {
        v.basePrice = bodyBase;
        break;
      }
    }

    // Append selected (priced) specs under the body description (only those with adders)
    const specLines = hiddenAdders
      .filter(a => a.specLabel && a.specValue)
      .map(a => `${a.specLabel}: ${a.specValue}`);

    if (specLines.length) {
      autoQuoteItems[bodyBaseKey].description = `${autoQuoteItems[bodyBaseKey].description}\nAdd-ons:\n- ${specLines.join("\n- ")}`;
    }
  }

  // Compute total base and apply upcharge on the sum (then rounding)
  const totalBase = visible.reduce((sum, v) => sum + (Number(v.basePrice) || 0), 0);
  const targetTotal = roundMoney(totalBase * (1 + upRate));

  // Compute per-line upcharged prices, round each, then reconcile rounding to match targetTotal
  let runningTotal = 0;
  for (const v of visible) {
    v.upPrice = roundMoney((Number(v.basePrice) || 0) * (1 + upRate));
    runningTotal += v.upPrice;
  }
  runningTotal = roundMoney(runningTotal);

  const diff = roundMoney(targetTotal - runningTotal);
  if (diff !== 0 && bodyBaseKey) {
    for (const v of visible) {
      if (v.key === bodyBaseKey) {
        v.upPrice = roundMoney(v.upPrice + diff);
        break;
      }
    }
  }

  // Render rows
  for (const v of visible) {
    const item = v.item;
    const displayPrice = `$${Number(v.upPrice || 0).toFixed(2)}`;

    const row = document.createElement("tr");
    row.innerHTML = `
      <td style="white-space:pre-line">${escapeHtml(item.description)}</td>
      <td>${escapeHtml(displayPrice)}</td>
    `;
    quoteBody.appendChild(row);
  }

  // Totals footer
  renderTotalFooter(quoteFoot, targetTotal);
}

function renderEditableQuote() {
  quoteBody.innerHTML = "";

  editableRows.forEach((item, index) => {
    const row = document.createElement("tr");
    row.dataset.index = String(index);

    row.draggable = true;             // REQUIRED for drag events
    row.classList.add("quote-row");   // optional, for styling/debugging

   row.innerHTML = `
  <td class="drag-handle" draggable="true" title="Drag to reorder">:::</td>
  <td contenteditable="true" data-field="description" data-index="${index}">
    ${escapeHtml(item.description)}
  </td>
  <td contenteditable="true" data-field="price" data-index="${index}">
    ${escapeHtml(String(item.price))}
  </td>
  <td>
    <button type="button" data-action="add" data-index="${index}">+</button>
    <button type="button" data-action="delete" data-index="${index}">-</button>
  </td>
  `;

    quoteBody.appendChild(row);
  });

  // Totals footer (sum of editable prices)
  const total = editableRows.reduce((s, r) => s + parseMoneyLoose(r.price), 0);
  renderTotalFooter(quoteFoot, total);
}


function renderQuote() {
  if (mode === "config") renderPreviewQuote();
  else renderEditableQuote();
}
function renderSavedQuotesList() {
  const bodyQuotes = getSavedBodyQuotes().map(q => ({ ...q, _type: "Body" }));
  const truckQuotes = getSavedTruckQuotes().map(q => ({ ...q, _type: "Truck" }));

  // Merge + sort newest first
  const all = [...bodyQuotes, ...truckQuotes].sort((a, b) => {
    const da = new Date(a.savedAt || a.id).getTime();
    const db = new Date(b.savedAt || b.id).getTime();
    return db - da;
  });

  savedQuotesList.innerHTML = "";

  if (all.length === 0) {
    savedQuotesList.innerHTML = "<p>No saved quotes yet.</p>";
    return;
  }

  all.forEach((q) => {
    const wrapper = document.createElement("div");
    wrapper.style.border = "1px solid #ccc";
    wrapper.style.padding = "10px";
    wrapper.style.marginBottom = "10px";

    const name = q.name ? q.name : `${q._type} Quote`;
    const when = q.savedAt ? new Date(q.savedAt).toLocaleString() : "";

    wrapper.innerHTML = `
      <div style="display:flex; justify-content:space-between; gap:12px; align-items:center;">
        <div>
          <div><strong>${escapeHtml(name)}</strong> <span style="opacity:.7">(${q._type})</span></div>
          <div style="opacity:.7; font-size: 12px;">${escapeHtml(when)}</div>
        </div>
        <div style="display:flex; gap:8px;">
          <button type="button" data-action="load" data-type="${q._type}" data-id="${q.id}">Load</button>
          <button type="button" data-action="rename" data-type="${q._type}" data-id="${q.id}">Rename</button>
          <button type="button" data-action="delete" data-type="${q._type}" data-id="${q.id}">Delete</button>
        </div>
      </div>
    `;

    savedQuotesList.appendChild(wrapper);
  });
}


function ensureEditHeaders() {
  const theadRow = document.querySelector("#quoteSection thead tr");
  if (!theadRow) return;

  // Desired headers in edit mode
  const desired = ["Move", "Description", "Price", "Actions"];

  // Clear and rebuild (simple and reliable)
  theadRow.innerHTML = "";
  desired.forEach(text => {
    const th = document.createElement("th");
    th.textContent = text;
    theadRow.appendChild(th);
  });
}

function ensurePreviewHeaders() {
  const theadRow = document.querySelector("#quoteSection thead tr");
  if (!theadRow) return;

  // Desired headers in preview mode
  const desired = ["Description", "Price"];

  theadRow.innerHTML = "";
  desired.forEach(text => {
    const th = document.createElement("th");
    th.textContent = text;
    theadRow.appendChild(th);
  });
}

// Adds/overwrites a line in an auto-quote map.
// NOTE: older call sites may only pass (map, key, itemNumber, description).
// Newer call sites may also pass (qty, hidden) so add-ons can be priced but not
// displayed as separate quote lines.
function addAutoItemMap(map, key, itemNumber, description, qty = 1, hidden = false) {
  if (!key) return;

  // Try to infer origin from the key pattern "fieldId:optValue:..."
  let sourceFieldId = "";
  let sourceOptValue = "";
  try {
    const parts = String(key).split(":");
    if (parts.length >= 1) sourceFieldId = parts[0] || "";
    if (parts.length >= 2) sourceOptValue = parts[1] || "";
  } catch {}

  map[key] = {
    itemNumber: itemNumber || "",
    description: description || "",
    qty: Number.isFinite(Number(qty)) ? Number(qty) : 1,
    hidden: Boolean(hidden),

    // Origin metadata used by the debug panel to show where an item came from
    sourceFieldId,
    sourceOptValue,

    // price fields will be filled by Striven after refreshAutoQuoteFromStriven()
    price: "",
    rawPrice: "",
    kind: ""
  };
}



function resolveTemplateItemNumber(fieldId, optValue, stateObj) {
  const field = pricingData[fieldId];
  const tpl = field && field.itemNumberTemplate ? String(field.itemNumberTemplate) : "";
  if (!tpl) return "";
  // Simple {key} substitution from state. Also allow {fieldId} current option.
  return tpl.replace(/\{([^}]+)\}/g, (m, key) => {
    if (key === fieldId) return String(optValue || "");
    return String((stateObj && stateObj[key]) || "");
  }).trim();
}

function addItemsFromOption(map, fieldId, optValue, optObj, stateObj) {
  if (!optObj) return;

  // Mark selections as "addons" via data.json with: quoteBehavior: "addon"
  const isAddonObj = (o) => (o && String(o.quoteBehavior || "").toLowerCase() === "addon");

  // If option defines multiple items, use them
  if (Array.isArray(optObj.items)) {
    const optLevelAddon = isAddonObj(optObj);
    optObj.items.forEach(it => {
      const num = String(it.itemNumber || "").trim();
      if (!num) return; // never create blank lines

      const hidden = isAddonObj(it) || optLevelAddon;
      addAutoItemMap(
        map,
        it.key || `${fieldId}:${optValue}:${num}`,
        num,
        "",
        1,
        hidden
      );
    });
    return;
  }

  // Otherwise fall back to one default item
  const itemNum = ((optObj && optObj.itemNumber)
    ? String(optObj.itemNumber)
    : resolveTemplateItemNumber(fieldId, optValue, stateObj)
  ).trim();

  if (!itemNum) return; // never create blank lines

  addAutoItemMap(
    map,
    `${fieldId}:${optValue}:${itemNum}`,
    itemNum,
    "",
    1,
    isAddonObj(optObj)
  );
}



quoteBody.addEventListener("input", (e) => {
  if (mode !== "edit") return;

  const cell = e.target;
  const index = Number(cell.dataset.index);
  const field = cell.dataset.field;
  if (Number.isNaN(index) || !field) return;

  if (field === "description") {
    editableRows[index].description = cell.textContent.trim();
  } else if (field === "price") {
    editableRows[index].price = cell.textContent.trim();
  }

  updateEditableTotal();
});

quoteBody.addEventListener("click", (e) => {
  if (mode !== "edit") return;

  const btn = e.target.closest("button");
  if (!btn) return;

  const action = btn.dataset.action;
  const index = Number(btn.dataset.index);
  if (Number.isNaN(index)) return;

  if (action === "add") {
    editableRows.splice(index + 1, 0, { description: "", price: "" });
    renderEditableQuote();
  }

  if (action === "delete") {
    editableRows.splice(index, 1);
    if (editableRows.length === 0) editableRows.push({ description: "", price: "" });
    renderEditableQuote();
  }
});

function updateEditableTotal() {
  const total = editableRows.reduce((s, r) => s + parseMoneyLoose(r.price), 0);
  renderTotalFooter(quoteFoot, total);
}


function populateDropdown(fieldId) {
  const select = document.getElementById(fieldId);
  if (!select) {
    console.warn(`populateDropdown: No <select id="${fieldId}"> found in HTML`);
    return;
  }
  const fieldData = pricingData[fieldId];
  if (!fieldData || !fieldData.options) {
    console.warn(`populateDropdown: No options found for "${fieldId}" in data.json`);
    return;
  }
  select.innerHTML = "";

  const defaultOption = document.createElement("option");
  defaultOption.value = "";
  defaultOption.textContent = "Select One";
  select.appendChild(defaultOption);

  for (const optionValue in fieldData.options) {
    const option = document.createElement("option");
    option.value = optionValue;
    option.textContent = optionValue;
    select.appendChild(option);
  }
}
function setOptionVisible(selectEl, value, visible) {
  const opt = Array.from(selectEl.options).find(o => o.value === value);
  if (!opt) return;

  // Hide in the dropdown (Chrome supports option.hidden)
  opt.hidden = !visible;

  // Also disable so it canâ€™t be selected via keyboard or weird browser behavior
  opt.disabled = !visible;

  // If the user currently has the hidden value selected, reset
  if (!visible && selectEl.value === value) {
    selectEl.value = "";
  }
}

function applyRules() {
  // 1) Apply data-driven hide/show rules first (may reset selections)
  applyDataDrivenRules("body", configuratorState);

  // 2) Build preview quote items (multi-line capable)
  // Clear current auto items so deselections remove lines
  for (const k in autoQuoteItems) delete autoQuoteItems[k];

  // Add items from each selected body field
  const bodyFields = getBodyFieldIdsFromPricingData(); // auto from data.json (excluding truck/rules)

  bodyFields.forEach((fieldId) => {
    if (pricingData[fieldId] && pricingData[fieldId].noQuoteItem) return;
    const selected = configuratorState[fieldId];
    if (!selected) return;

    const field = pricingData[fieldId];
    if (!field || !field.options) return;

    const optObj = field.options[selected];
    addItemsFromOption(autoQuoteItems, fieldId, selected, optObj, configuratorState);
    // Hidden body spec adders (priced in Striven, not displayed as lines)
    if (optObj && optObj.adderItemNumber) {
      const adderNum = String(optObj.adderItemNumber).trim();
      if (adderNum) {
        const adderKey = `adder:${fieldId}:${selected}:${adderNum}`;
        addAutoItemMap(autoQuoteItems, adderKey, adderNum, "");
        const adderObj = autoQuoteItems[adderKey];
        if (adderObj) {
          adderObj.hidden = true;
          adderObj.specLabel = (pricingData[fieldId] && pricingData[fieldId].label) ? pricingData[fieldId].label : fieldId;
          adderObj.specValue = selected;
        }
      }
    }

  });

  // 3) Add rule-based items (rules.body[].addItems)
  const rules = getRules("body");
  for (const rule of rules) {
    if (!matchesWhen(configuratorState, rule.when || {})) continue;

    const addList = rule.addItems || [];
    addList.forEach(it => {
      addAutoItemMap(autoQuoteItems, it.key, it.itemNumber, "");
      const obj = autoQuoteItems[it.key];
      if (obj) {
        if (it.hidden) obj.hidden = true;
        if (it.specLabel) obj.specLabel = it.specLabel;
        if (it.specValue) obj.specValue = it.specValue;
      }
    });
  }
    // TEST: force-add one SRG line (proof the backend integration works)
  //addAutoItemMap(
    //autoQuoteItems,
    //"SRG82-079-01",
    //"SRG82-079-01",
    //"Install Cab Shield & Gussets"
  //);

  refreshAutoQuoteFromStriven().catch(console.error);

  // 4) Render preview
  renderQuote(); // your preview renderer will list everything in autoQuoteItems
}

function escapeHtml(str) {
  return String(str)
    .replaceAll("&", "&amp;")
    .replaceAll("<", "&lt;")
    .replaceAll(">", "&gt;")
    .replaceAll('"', "&quot;")
    .replaceAll("'", "&#039;");
}

let draggedIndex = null;

quoteBody.addEventListener("dragstart", (e) => {

  if (mode !== "edit") return;

  const handle = e.target.closest(".drag-handle");
  if (!handle) return;

  const row = handle.closest("tr");
  if (!row) return;

  draggedIndex = Number(row.dataset.index);
  console.log("dragstart fired from index", draggedIndex);
  if (Number.isNaN(draggedIndex)) return;

  // Required: tell Chrome we're moving something
  e.dataTransfer.setData("text/plain", String(draggedIndex));
  e.dataTransfer.effectAllowed = "move";

  row.classList.add("dragging");
});


quoteBody.addEventListener("dragend", (e) => {
  const row = e.target.closest("tr");
  if (row) row.classList.remove("dragging");
});

quoteBody.addEventListener("dragover", (e) => {
  if (mode !== "edit") return;
  e.preventDefault();
  e.dataTransfer.dropEffect = "move";
});

quoteBody.addEventListener("drop", (e) => {
  if (mode !== "edit") return;
  e.preventDefault();

  const dropRow = e.target.closest("tr");
  if (!dropRow) return;

  const toIndex = Number(dropRow.dataset.index);
  const fromIndex = draggedIndex !== null
    ? draggedIndex
    : Number(e.dataTransfer.getData("text/plain"));

  if (Number.isNaN(fromIndex) || Number.isNaN(toIndex)) return;
  if (fromIndex === toIndex) return;

  const [moved] = editableRows.splice(fromIndex, 1);
  editableRows.splice(toIndex, 0, moved);

  draggedIndex = null;
  renderEditableQuote();
});
bodyQuoteNext.addEventListener("click", () => {
  // Move from body quote edit into truck builder
  setModeClass(null);

  // Hide body builder grid and show truck builder grid
  if (bodyBuilderGrid) bodyBuilderGrid.style.display = "none";
  if (truckBuilderGrid) truckBuilderGrid.style.display = "grid";

  // Ensure correct inner visibility
  quoteSection.style.display = "none";
  bodyQuoteActions.style.display = "none";

  truckConfigurator.style.display = "block";
  truckQuoteSection.style.display = "block";
  truckQuoteActions.style.display = "none";

  ensureTruckPreviewHeaders();
  renderTruckPreview();
});



function renderTruckQuote() {
  ensureTruckEditHeaders();
  truckQuoteBody.innerHTML = "";

  truckEditableRows.forEach((item, index) => {
    const row = document.createElement("tr");
    row.dataset.index = String(index);

    row.innerHTML = `
      <td class="drag-handle" draggable="true" title="Drag to reorder">:::</td>
      <td contenteditable="true" data-field="description" data-index="${index}">${escapeHtml(item.description ?? "")}</td>
      <td contenteditable="true" data-field="price" data-index="${index}">${escapeHtml(String(item.price ?? ""))}</td>
      <td>
        <button type="button" data-action="add" data-index="${index}">+</button>
        <button type="button" data-action="delete" data-index="${index}">-</button>
      </td>
    `;

    truckQuoteBody.appendChild(row);
  });


  const total = truckEditableRows.reduce((s, r) => s + parseMoneyLoose(r.price), 0);
  renderTotalFooter(truckQuoteFoot, total);
}

truckQuoteBack.addEventListener("click", () => {
  // Back from truck quote edit to truck configurator questions
  setModeClass(null);

  if (truckBuilderGrid) truckBuilderGrid.style.display = "grid";
  truckQuoteSection.style.display = "none";
  truckQuoteActions.style.display = "none";

  truckConfigurator.style.display = "block";
  ensureTruckPreviewHeaders();
  renderTruckPreview();
});
truckQuoteBody.addEventListener("input", (e) => {
  const cell = e.target;
  const index = Number(cell.dataset.index);
  const field = cell.dataset.field;
  if (Number.isNaN(index) || !field) return;

  if (field === "description") {
    truckEditableRows[index].description = cell.textContent.trim();
  } else if (field === "price") {
    truckEditableRows[index].price = cell.textContent.trim();
  }


  const total = truckEditableRows.reduce((s, r) => s + parseMoneyLoose(r.price), 0);
  renderTotalFooter(truckQuoteFoot, total);
});
truckQuoteBody.addEventListener("click", (e) => {
  const btn = e.target.closest("button");
  if (!btn) return;

  const action = btn.dataset.action;
  const index = Number(btn.dataset.index);
  if (Number.isNaN(index)) return;

  if (action === "add") {
    truckEditableRows.splice(index + 1, 0, { description: "", price: "" });
    renderTruckQuote();
  }

  if (action === "delete") {
    truckEditableRows.splice(index, 1);
    if (truckEditableRows.length === 0) truckEditableRows.push({ description: "", price: "" });
    renderTruckQuote();
  }
});
truckQuoteBody.addEventListener("dragstart", (e) => {
  const handle = e.target.closest(".drag-handle");
  if (!handle) return;

  const row = handle.closest("tr");
  if (!row) return;

  truckDraggedIndex = Number(row.dataset.index);
  if (Number.isNaN(truckDraggedIndex)) return;

  e.dataTransfer.setData("text/plain", String(truckDraggedIndex));
  e.dataTransfer.effectAllowed = "move";

  row.classList.add("dragging");
});

truckQuoteBody.addEventListener("dragend", (e) => {
  const row = e.target.closest("tr");
  if (row) row.classList.remove("dragging");
});

truckQuoteBody.addEventListener("dragover", (e) => {
  e.preventDefault();
  e.dataTransfer.dropEffect = "move";
});

truckQuoteBody.addEventListener("drop", (e) => {
  e.preventDefault();

  const dropRow = e.target.closest("tr");
  if (!dropRow) return;

  const toIndex = Number(dropRow.dataset.index);
  const fromIndex = truckDraggedIndex !== null
    ? truckDraggedIndex
    : Number(e.dataTransfer.getData("text/plain"));

  if (Number.isNaN(fromIndex) || Number.isNaN(toIndex)) return;
  if (fromIndex === toIndex) return;

  const [moved] = truckEditableRows.splice(fromIndex, 1);
  truckEditableRows.splice(toIndex, 0, moved);

  truckDraggedIndex = null;
  renderTruckQuote();
});

printTruckQuoteBtn.addEventListener("click", () => {
  alert("Truck Quote Print (placeholder).");
});

savedQuotesList.addEventListener("click", (e) => {
  const btn = e.target.closest("button");
  if (!btn) return;

  const action = btn.dataset.action;
  const type = btn.dataset.type; // "Body" or "Truck"
  const id = btn.dataset.id;

  if (!action || !type || !id) return;

  if (action === "load") {
    const list = type === "Body" ? getSavedBodyQuotes() : getSavedTruckQuotes();
    const found = list.find(q => q.id === id);
    if (!found) return alert("Could not find that saved quote.");

    hideAllScreens();

    // Hide Saved Quotes screen + buttons
    savedQuotesScreen.style.display = "none";

    // Load into the app
    if (type === "Body") loadBodyQuote(found);
    else loadTruckQuote(found);

    return;
  }

  if (action === "rename") {
    const newName = prompt("Enter a new name:", "");
    if (!newName || !newName.trim()) return;

    if (type === "Body") {
      const list = getSavedBodyQuotes();
      const q = list.find(x => x.id === id);
      if (!q) return;
      q.name = newName.trim();
      setSavedBodyQuotes(list);
    } else {
      const list = getSavedTruckQuotes();
      const q = list.find(x => x.id === id);
      if (!q) return;
      q.name = newName.trim();
      setSavedTruckQuotes(list);
    }

    renderSavedQuotesList();
    return;
  }

  if (action === "delete") {
    const ok = confirm(`Delete this ${type} quote?`);
    if (!ok) return;

    if (type === "Body") {
      const list = getSavedBodyQuotes().filter(q => q.id !== id);
      setSavedBodyQuotes(list);
    } else {
      const list = getSavedTruckQuotes().filter(q => q.id !== id);
      setSavedTruckQuotes(list);
    }

    renderSavedQuotesList();
    return;
  }
});


function getTruckSelect(fieldId) {
  return document.getElementById(fieldId);
}

function renderTruckPreview() {
  ensureTruckPreviewHeaders();
  truckQuoteBody.innerHTML = "";

  for (const key in autoTruckQuoteItems) {
    const item = autoTruckQuoteItems[key];

    const row = document.createElement("tr");
    row.innerHTML = `
      <td>${escapeHtml(item.description)}</td>
      <td>$${Number(item.price).toFixed(2)}</td>
    `;
    truckQuoteBody.appendChild(row);
  }


  const total = Object.values(autoTruckQuoteItems).reduce((s, it) => s + parseMoneyLoose(it.price), 0);
  renderTotalFooter(truckQuoteFoot, total);
}

function getCombinedTruckState() {
  // Truck rules sometimes depend on body selections too
  return { ...configuratorState, ...truckConfiguratorState };
}

function applyTruckRules() {
  const combinedState = getCombinedTruckState();
  applyDataDrivenRules("truck", combinedState);

  // show preview table while configuring truck
  truckQuoteSection.style.display = "block";
  truckQuoteActions.style.display = "none";

    const truck = pricingData.truck;
  if (!truck) return;

  // Start fresh each time (so removed selections remove items)
  for (const k in autoTruckQuoteItems) delete autoTruckQuoteItems[k];

  // 1) Add items from each selected option
  for (const fieldId in truck) {
    const selected = truckConfiguratorState[fieldId];
    if (!selected) continue;

    const optObj = truck[fieldId].options[selected];
    addItemsFromOption(autoTruckQuoteItems, fieldId, selected, optObj, truckConfiguratorState);
  }

  // 2) Add rule-based items (rules.truck[].addItems)
  const rules = getRules("truck");
  for (const rule of rules) {
    if (!matchesWhen(combinedState, rule.when || {})) continue;

    const addList = rule.addItems || [];
    addList.forEach(it => {
      addAutoItemMap(autoTruckQuoteItems, it.key, it.itemNumber, "");
      const obj = autoTruckQuoteItems[it.key];
      if (obj) {
        if (it.hidden) obj.hidden = true;
        if (it.specLabel) obj.specLabel = it.specLabel;
        if (it.specValue) obj.specValue = it.specValue;
      }
    });
  }

  // Render immediately (so user sees selections), then resolve from Striven
  renderTruckPreview();
  refreshAutoTruckQuoteFromStriven().catch(err => {
    console.error(err);
    try { if (window.DEBUG) window.DEBUG.log(`Truck Striven refresh error: ${String(err?.message || err)}`); } catch {}
  });
}
truckNext.addEventListener("click", () => {
  truckMode = "edit";
  setModeClass("mode-truck-quote");

  truckEditableRows = Object.values(autoTruckQuoteItems).map(item => ({
    description: item.description,
    price: item.price
  }));

  // Carry body rows in too (optional now, but you probably want it)
  truckEditableRows = [
    ...editableRows.map(r => ({ ...r })),
    ...truckEditableRows
  ];

  if (truckEditableRows.length === 0) {
    truckEditableRows.push({ description: "", price: "" });
  }

  // Keep grid visible; hide only the scrolling questions panel
  if (truckBuilderGrid) truckBuilderGrid.style.display = "grid";
  truckConfigurator.style.display = "none";
  truckQuoteSection.style.display = "block";
  truckQuoteActions.style.display = "block";

  renderTruckQuote();
});

truckBack.addEventListener("click", () => {
  // Back from truck builder to body quote edit
  setModeClass("mode-body-quote");

  // Show body grid quote-only
  if (truckBuilderGrid) truckBuilderGrid.style.display = "none";
  if (bodyBuilderGrid) bodyBuilderGrid.style.display = "grid";

  configurator.style.display = "none";
  quoteSection.style.display = "block";
  bodyQuoteActions.style.display = "block";

  // Hide truck panels
  truckConfigurator.style.display = "none";
  truckQuoteSection.style.display = "none";
  truckQuoteActions.style.display = "none";
});

function ensureTruckEditHeaders() {
  const theadRow = document.querySelector("#truckQuoteSection thead tr");
  if (!theadRow) return;

  theadRow.innerHTML = "";
  ["Move", "Description", "Price", "Actions"].forEach(t => {
    const th = document.createElement("th");
    th.textContent = t;
    theadRow.appendChild(th);
  });
}

function ensureTruckPreviewHeaders() {
  const theadRow = document.querySelector("#truckQuoteSection thead tr");
  if (!theadRow) return;

  theadRow.innerHTML = "";
  ["Description", "Price"].forEach(t => {
    const th = document.createElement("th");
    th.textContent = t;
    theadRow.appendChild(th);
  });
}


// -------------------------
// SAVE / LOAD (Body Quote) using localStorage
// -------------------------

const STORAGE_KEY_BODY_QUOTES = "bodyQuotes";

// Returns array of saved quotes
function getSavedBodyQuotes() {
  try {
    const raw = localStorage.getItem(STORAGE_KEY_BODY_QUOTES);
    return raw ? JSON.parse(raw) : [];
  } catch {
    return [];
  }
}

// Saves array back to localStorage
function setSavedBodyQuotes(quotes) {
  localStorage.setItem(STORAGE_KEY_BODY_QUOTES, JSON.stringify(quotes));
}

// Build the object we want to save
function buildBodyQuoteSaveObject() {
  return {
    id: new Date().toISOString(),            // unique-ish id
    savedAt: new Date().toISOString(),
    stage: "body_quote",
    body: {
      selections: { ...configuratorState },  // bodySeries/bodyLength/etc
      editableRows: editableRows.map(r => ({
        description: r.description ?? "",
        price: r.price ?? ""
      }))
    }
  };
}


// PRINT button (placeholder for now)
printQuoteBtn.addEventListener("click", () => {
  alert("Print is not finalized yet. Placeholder button works!");
  // Later we can replace with: window.print();
});


// -------------------------
// COPY TO STRIVEN (inline HTML only)
// -------------------------

function readEditableRowsFromTableBody(tbodyEl) {
  if (!tbodyEl) return [];

  const out = [];
  const trs = Array.from(tbodyEl.querySelectorAll("tr"));
  trs.forEach((tr) => {
    const descCell = tr.querySelector('td[data-field="description"]');
    const priceCell = tr.querySelector('td[data-field="price"]');

    // In preview mode there are no data-field attrs, so fall back to raw cells
    const tds = Array.from(tr.querySelectorAll("td"));
    const desc = (descCell ? descCell.innerText : (tds[0]?.innerText || "")).trim();
    const price = (priceCell ? priceCell.innerText : (tds[1]?.innerText || "")).trim();

    if (desc || price) out.push({ description: desc, price });
  });

  return out;
}

function formatStrivenMoney(value) {
  const n = parseMoneyLoose(value);
  if (!Number.isFinite(n) || n === 0 && String(value).trim() === "") return "";
  return String(Math.round(n * 100) / 100);
}

/**
 * Builds the specific HTML table format required for Striven.
 * Generates 46 rows with alternating background colors.
 */
function buildStrivenWorkTableHtml(rows) {
  const headerHtml = `
    <thead>
        <tr>
            <th style="text-align: center; width: 85%; height: 50px">
                <font size="4" style="">Description of Work to be Performed</font>
            </th>
            <th style="text-align: center; width: 15%; height: 50px">
                <font size="4" style="">Total $</font>
            </th>
        </tr>
    </thead>`;

  let bodyRowsHtml = "";
  
  // The requested template contains 46 rows. 
  // We loop 46 times to ensure the table structure is identical every time.
  for (let i = 0; i < 46; i++) {
    const rowData = rows[i] || { description: "", price: "" };
    const isEven = i % 2 === 0;
    const rowAttr = isEven ? "" : ' bgcolor="#e6f2ff"';

    bodyRowsHtml += `
        <tr${rowAttr}>
            <td style="text-align: left; height: 25px; font-size: 12pt">${rowData.description || ""}</td>
            <td style="text-align: right; font-size: 12pt">${rowData.price || ""}</td>
        </tr>`;
  }

  return `
<table border="1" cellpadding="5" cellspacing="0" style="width: 100%; border-collapse: collapse">
    ${headerHtml}
    <tbody>
        ${bodyRowsHtml}
    </tbody>
</table>`.trim();
}

async function copyHtmlToClipboard(html) {
  const plain = html.replace(/<[^>]+>/g, " ").replace(/\s+/g, " ").trim();

  // Best: copy as real HTML so Striven rich-text paste preserves table structure
  try {
    if (navigator.clipboard && window.ClipboardItem) {
      const item = new ClipboardItem({
        "text/html": new Blob([html], { type: "text/html" }),
        "text/plain": new Blob([plain], { type: "text/plain" })
      });
      await navigator.clipboard.write([item]);
      return true;
    }
  } catch {}

  // Fallback: copy the HTML string
  try {
    if (navigator.clipboard && navigator.clipboard.writeText) {
      await navigator.clipboard.writeText(html);
      return true;
    }
  } catch {}

  // Last-resort: prompt
  window.prompt("Copy this HTML into Striven:", html);
  return false;
}

if (copyBodyToStrivenBtn) {
  copyBodyToStrivenBtn.addEventListener("click", async () => {
    const rows = readEditableRowsFromTableBody(document.getElementById("quoteBody"));
    const html = buildStrivenWorkTableHtml(rows);
    await copyHtmlToClipboard(html);
    alert("Copied Body Quote to clipboard (inline HTML) for Striven.");
  });
}

if (copyTruckToStrivenBtn) {
  copyTruckToStrivenBtn.addEventListener("click", async () => {
    const rows = readEditableRowsFromTableBody(document.getElementById("truckQuoteBody"));
    const html = buildStrivenWorkTableHtml(rows);
    await copyHtmlToClipboard(html);
    alert("Copied Truck Quote to clipboard (inline HTML) for Striven.");
  });
}


// Actually restore the saved quote into the app
function loadBodyQuote(saved) {
  // 1) Restore configurator selections
  const sel = saved?.body?.selections || {};
  configuratorState.bodySeries = sel.bodySeries || "";
  configuratorState.bodyLength = sel.bodyLength || "";

  // Sync dropdown UI too (so Back-to-config later can work)
  bodySeriesSelect.value = configuratorState.bodySeries;
  bodyLengthSelect.value = configuratorState.bodyLength;

  // 2) Restore editable rows
  editableRows = (saved?.body?.editableRows || []).map(r => ({
    description: r.description ?? "",
    price: r.price ?? ""
  }));

  if (editableRows.length === 0) {
    editableRows.push({ description: "", price: "" });
  }

  // 3) Switch into edit mode and show the quote UI
  mode = "edit";
  ensureEditHeaders();
  quoteSection.style.display = "block";
  configurator.style.display = "none";
  blankQuote.style.display = "none";

  // Hide start buttons like you do when starting fresh
  startBlank.style.display = "none";
  startConfigurator.style.display = "none";
  bodyQuoteActions.style.display = "block";

  // 4) Render editable quote
  renderQuote();
}

// -------------------------
// SAVE / LOAD (Truck Quote) using localStorage
// -------------------------

const STORAGE_KEY_TRUCK_QUOTES = "truckQuotes";

function getSavedTruckQuotes() {
  try {
    const raw = localStorage.getItem(STORAGE_KEY_TRUCK_QUOTES);
    return raw ? JSON.parse(raw) : [];
  } catch {
    return [];
  }
}

function setSavedTruckQuotes(quotes) {
  localStorage.setItem(STORAGE_KEY_TRUCK_QUOTES, JSON.stringify(quotes));
}

function buildTruckQuoteSaveObject() {
  return {
    id: new Date().toISOString(),
    savedAt: new Date().toISOString(),
    stage: "truck_quote",
    // Later weâ€™ll also save truckConfiguratorState selections here
    truck: {
      editableRows: truckEditableRows.map(r => ({
        description: r.description ?? "",
        price: r.price ?? ""
      }))
    },
    // Optional: carry body selections forward for reference
    body: {
      selections: { ...configuratorState }
    }
  };
}

// SAVE Truck Quote button
saveTruckQuoteBtn.addEventListener("click", () => {
  const quotes = getSavedTruckQuotes();
  const saveObj = buildTruckQuoteSaveObject();

  const name = prompt("Name this saved Truck Quote (optional):", "");
  if (name && name.trim()) saveObj.name = name.trim();

  quotes.unshift(saveObj);
  setSavedTruckQuotes(quotes);

  alert("Saved Truck Quote!");
});

function loadTruckQuote(saved) {
  // Restore truck quote rows
  truckEditableRows = (saved?.truck?.editableRows || []).map(r => ({
    description: r.description ?? "",
    price: r.price ?? ""
  }));

  if (truckEditableRows.length === 0) {
    truckEditableRows.push({ description: "", price: "" });
  }

  // Hide everything else
  configurator.style.display = "none";
  quoteSection.style.display = "none";
  bodyQuoteActions.style.display = "none";
  truckConfigurator.style.display = "none";

  // Hide start screen buttons
  startBlank.style.display = "none";
  startConfigurator.style.display = "none";
  

  // Show truck quote + actions
  truckQuoteSection.style.display = "block";
  truckQuoteActions.style.display = "block";

  // Render it
  renderTruckQuote();
}

});